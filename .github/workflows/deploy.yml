name: CI/CD Pipeline

on:
  push:
    branches: [ master ]
  # Optional: Keep for PR validation
  # pull_request:
  #   branches: [ master ]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Log in to the Container registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata (tags, labels) for Backend
        id: meta-backend
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/backend
          tags: |
            type=ref,event=branch
            type=sha,prefix={{branch}}-,format=short
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Backend image
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          push: true
          tags: ${{ steps.meta-backend.outputs.tags }}
          labels: ${{ steps.meta-backend.outputs.labels }}

      - name: Extract metadata (tags, labels) for Frontend
        id: meta-frontend
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/frontend
          tags: |
            type=ref,event=branch
            type=sha,prefix={{branch}}-,format=short
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Frontend image
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          push: true
          tags: ${{ steps.meta-frontend.outputs.tags }}
          labels: ${{ steps.meta-frontend.outputs.labels }}

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/master'
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Ensure nginx directory exists on server
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.HOST }}
          username: ${{ secrets.USERNAME }}
          key: ${{ secrets.SSH_KEY }}
          script: |
            mkdir -p ~/app/nginx

      - name: Copy docker-compose and nginx config to server
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.HOST }}
          username: ${{ secrets.USERNAME }}
          key: ${{ secrets.SSH_KEY }}
          source: "docker-compose.prod.yml,nginx/"
          target: "~/app"
          strip_components: 0

      - name: Deploy to server
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.HOST }}
          username: ${{ secrets.USERNAME }}
          key: ${{ secrets.SSH_KEY }}
          script: |
            cd ~/app
            
            # Create .env file with secure permissions
            cat > .env << 'EOF'
            POSTGRES_USER=${{ secrets.POSTGRES_USER }}
            POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
            POSTGRES_DB=${{ secrets.POSTGRES_DB }}
            JWT_SECRET=${{ secrets.JWT_SECRET }}
            NODE_ENV=production
            EOF
            chmod 600 .env
            
            # Login to GHCR
            echo ${{ secrets.GITHUB_TOKEN }} | docker login ghcr.io -u ${{ github.actor }} --password-stdin
            
            # Pull latest images
            docker-compose -f docker-compose.prod.yml pull
            
            # Stop and remove old containers (preserving volumes)
            docker-compose -f docker-compose.prod.yml down --remove-orphans
            
            # Run migrations BEFORE starting new backend
            echo "ğŸš€ Running database migrations..."
            docker-compose -f docker-compose.prod.yml run --rm backend npx prisma migrate deploy || {
              echo "âŒ Migration failed!"
              exit 1
            }
            
            # Start all services
            docker-compose -f docker-compose.prod.yml up -d
            
            # Wait for services to be healthy
            echo "â³ Waiting for services to be ready..."
            
            # Wait for PostgreSQL
            for i in {1..30}; do
              if docker-compose -f docker-compose.prod.yml exec -T postgres pg_isready -U ${{ secrets.POSTGRES_USER }}; then
                echo "âœ… PostgreSQL is ready!"
                break
              fi
              if [ $i -eq 30 ]; then
                echo "âŒ PostgreSQL health check timeout"
                exit 1
              fi
              sleep 2
            done
            
            # Wait for backend
            for i in {1..30}; do
              if curl -s -f http://localhost:3000/api/health > /dev/null; then
                echo "âœ… Backend is ready!"
                break
              fi
              if [ $i -eq 30 ]; then
                echo "âš ï¸ Backend health check timeout (checking logs...)"
                docker-compose -f docker-compose.prod.yml logs backend --tail=20
                exit 1
              fi
              sleep 3
            done
            
            # Verify nginx configuration
            docker-compose -f docker-compose.prod.yml exec nginx nginx -t || {
              echo "âŒ nginx configuration error"
              exit 1
            }
            
            # Reload nginx
            docker-compose -f docker-compose.prod.yml exec nginx nginx -s reload 2>/dev/null || true
            
            # Show deployment status
            echo "ğŸ“Š Deployment Status:"
            docker-compose -f docker-compose.prod.yml ps
            
            # Clean up old images (keep last 2 tags)
            echo "ğŸ§¹ Cleaning up old images..."
            docker image prune -f --filter "until=48h"
            
            # Create database backup (optional)
            echo "ğŸ’¾ Creating database backup..."
            BACKUP_FILE="backup_$(date +%Y%m%d_%H%M%S).sql"
            docker-compose -f docker-compose.prod.yml exec -T postgres pg_dump -U ${{ secrets.POSTGRES_USER }} ${{ secrets.POSTGRES_DB }} > "$BACKUP_FILE" 2>/dev/null && \
            echo "âœ… Backup created: $BACKUP_FILE" || \
            echo "âš ï¸ Backup skipped or failed"
            
            echo "ğŸ‰ Deployment completed successfully!"